'''
Play a match of blackjack using card scanning to determine winning probabilities using a Raspberry PI.\n
Requires a csv generated by the scan_cards.py script.\n
This script is adapted to be used with an SSD1306 Oled screen and 3 buttons to indicate actions.\n
Author: Leah Castro.\n
No copiar, no distribuír y definitivamente refactoricen antes de subirlo.
'''

import cv2 as cv
from time import perf_counter, sleep
from cards import *
from luma.core.interface.serial import i2c
from luma.core.render import canvas
from luma.oled.device import ssd1306
from gpiozero import Button, LED

def get_chance(deck, pool):
    deck_val = sum([VALUES[card[0]] for card in deck])
    favorable = [card for card in pool if VALUES[card[0]] <= 21 - deck_val]
    return format(len(favorable) / len(pool), ".0%")

def takec(card):
    deck.append(card)
    deck_val = sum([VALUES[card[0]] for card in deck])
    print(f"Current deck: {deck}, value: {deck_val}")
    pool.remove(card)
    return get_chance(deck, pool)

def discardc(card):
    pool.remove(card)
    print(f"Removed card {card} from pool")
    return get_chance(deck, pool)

def beep():
    beeper.on()
    sleep(0.5)
    beeper.off()

SCREEN_W = 128
SCREEN_H = 64

serial = i2c(port=1, address=0x3C)
screen = ssd1306(serial, rotate=0)
take = Button(4)
discard = Button(22)
reset = Button(17)
beeper = LED(27)

card_scan = scanner(200, 0.2, 0.1, 0.155)
card_find = card_interpreter('/home/solis/card_reader/sorted_corners.csv', card_scan)

CAP_DEVICE = 0
FRAME_COUNT = 30 #number of frames that the scanner uses to identify cards
IDLE_TIME = 2 #time when no detection occurs after showing a card
VALUES = {
    'A':1,
    '2':2,
    '3':3,
    '4':4,
    '5':5,
    '6':6,
    '7':7,
    '8':8,
    '9':9,
    '10':10,
    'J':11,
    'Q':12,
    'K':13
}

SYM_NAMES = {
    '':'',
    '♠':'Spades',
    '♣':'Clubs',
    '♥':'Hearts',
    '♦':'Diamonds'
}

cap = initiate_capture(CAP_DEVICE)

while True:
    #Runtime variables
    deck = []
    frame_corners = []
    corner_count = []
    rec_frames = 0
    idle = perf_counter()
    in_cam = ["",""]
    pool = [card[0] for card in card_find.cards_list]
    any_pressed = False
    chance = "100%"

    while not reset.is_pressed:
        with canvas(screen) as draw:
            draw.text((0, 0), f"success: {chance}", fill="white")
            draw.text((42, 52), f"{in_cam[0]}  {SYM_NAMES[in_cam[1]]}", fill="white", align="center")
            frame = get_frame(cap)
            card_scan.get_frame_modes(frame)

            #Check if there's a defined contour
            if not card_scan.get_card_edges(draw):
                frame_corners = []
                corner_count = []
                rec_frames = 0
                idle = perf_counter()
                in_cam = ["",""]
            else:
                if perf_counter() - idle > IDLE_TIME:

                    frame_corners = card_scan.get_card_corners()
                    if frame_corners:        
                        corner_count.append(len(frame_corners))
                        rec_frames += 1

                        if rec_frames >= FRAME_COUNT:
                            average = sum(corner_count) / rec_frames
                            in_cam = card_find.identify_card(frame_corners, average)
                            #reset variables
                            frame_corners = []
                            corner_count = []
                            rec_frames = 0

            if any_pressed != (take.is_pressed or discard.is_pressed) and not in_cam == ['','']:
                if take.is_pressed:
                    beep()
                    chance = takec(in_cam)
                    any_pressed = True

                elif discard.is_pressed:
                    beep()
                    chance = discardc(in_cam)
                    any_pressed = True
                
                else:
                    any_pressed = False
    beep()